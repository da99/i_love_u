// Generated by CoffeeScript 1.3.3
(function() {
  var Arguments_Match, funcy_perm, rw, surgeon, _;

  rw = require("rw_ize");

  funcy_perm = require("funcy_perm");

  surgeon = require("array_surgeon");

  _ = require("underscore");

  Arguments_Match = (function() {

    rw.ize(Arguments_Match);

    Arguments_Match.read_able("list", "env", "line", "code", "line_arr", "slice_desc", "args");

    Arguments_Match.read_write_able_bool("is_a_match");

    Arguments_Match.extract_args = function(match, list) {
      var a, args, end, i, slice, start, _i, _len;
      start = match.slice_desc().start_index;
      end = match.slice_desc().end_index;
      slice = match.slice_desc().slice;
      args = [];
      if (slice.length !== list.length) {
        throw new Error("Slice does not match list length: " + slice.length + " != " + list.length + ". Check start and end positions.");
      }
      for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
        a = list[i];
        if (!a.is_plain_text()) {
          args.push(slice[i]);
        }
      }
      return args;
    };

    Arguments_Match.permutate = function(env, line_arr, code) {
      var clone, data_pos, group, i, ind, perms, raw_perms, str, _i, _j, _len, _len1;
      data_pos = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = line_arr.length; _i < _len; i = ++_i) {
          str = line_arr[i];
          if (env.is_name_of_data(str)) {
            _results.push(i);
          }
        }
        return _results;
      })();
      raw_perms = funcy_perm(data_pos).perm(function(val, i) {
        return -1;
      });
      perms = [];
      for (_i = 0, _len = raw_perms.length; _i < _len; _i++) {
        group = raw_perms[_i];
        clone = line_arr.slice(0);
        for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
          ind = group[_j];
          if (ind !== -1) {
            clone[ind] = env.data(clone[ind], line_arr, code);
          }
        }
        perms.push(clone);
      }
      return perms;
    };

    function Arguments_Match(arg_list, env, line_n_code, proc) {
      var a, a_i, code, combo, desc_slice, final_line_arr, finders, i, limit, line, list, perms, pi, print_it, _i, _j, _len, _len1, _ref;
      line = line_n_code[0];
      code = line_n_code[1];
      this.rw_data().list = arg_list.list();
      this.rw_data().env = env;
      this.rw_data().line = line;
      this.rw_data().code = code;
      this.rw_data().args = [];
      perms = this.constructor.permutate(env, line, code);
      list = this.list();
      finders = [];
      print_it = false;
      _ref = this.list();
      for (a_i = _i = 0, _len = _ref.length; _i < _len; a_i = ++_i) {
        a = _ref[a_i];
        finders.push(function(v, i, fi) {
          var arg, last_i;
          arg = list[fi];
          if (!arg) {
            return false;
          }
          if (!(arg.is_splat && arg.is_splat())) {
            if (arg.is_start()) {
              if (i !== 0) {
                return false;
              }
            }
            if (arg.is_end()) {
              last_i = perms[0].length - 1;
              if (i !== last_i) {
                return false;
              }
            }
          }
          return arg.is_a_match_with(v);
        });
        if (a.is_splat && a.is_splat()) {
          _.last(finders).is_splat = true;
        }
      }
      pi = 0;
      limit = perms[0].length - finders.length;
      final_line_arr = null;
      desc_slice = null;
      while (true) {
        for (i = _j = 0, _len1 = perms.length; _j < _len1; i = ++_j) {
          combo = perms[i];
          desc_slice = surgeon(combo).describe_slice(finders, pi);
          if (desc_slice) {
            final_line_arr = combo;
            break;
          }
        }
        if (final_line_arr) {
          this.is_a_match(true);
          this.rw_data().line_arr = final_line_arr;
          this.rw_data().slice_desc = desc_slice;
          this.rw_data().args = this.constructor.extract_args(this, list);
          proc(this);
          if (!this.is_a_match()) {
            final_line_arr = null;
          }
        }
        pi += 1;
        if (final_line_arr || (pi >= limit)) {
          break;
        }
      }
      if (!final_line_arr || !this.is_a_match()) {
        return null;
      }
    }

    Arguments_Match.prototype.replace = function(val) {
      var i, l;
      i = this.slice_desc().start_index;
      l = this.slice_desc().length;
      this.line_arr().splice(i, l, val);
      this.rw_data().line = this.line_arr();
      return this.line();
    };

    return Arguments_Match;

  })();

  module.exports = Arguments_Match;

}).call(this);
