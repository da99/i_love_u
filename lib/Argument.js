// Generated by CoffeeScript 1.3.3
(function() {
  var Argument, XRegExp, rw, _;

  rw = require("rw_ize");

  _ = require("underscore");

  XRegExp = require('xregexp').XRegExp;

  Argument = (function() {

    Argument.types = function() {
      var t, _ref;
      return (_ref = this._types_) != null ? _ref : this._types_ = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = ['splat', 'WORD', 'NUM', 'CHAR', 'ANY', 'Noun', 'true', 'true_or_false', 'false'];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          t = _ref1[_i];
          _results.push(this[t]);
        }
        return _results;
      }).call(this);
    };

    Argument.escaped_end_period = /\\\.$/;

    Argument.regexp_types_used = /\!\>([^\s]+)\</g;

    Argument.regexp_any_type = /(\!\>[^\s]+\<)/g;

    Argument.regexp_capture_any_type = function() {
      var _ref;
      return (_ref = this._regexp_capture_any_type_) != null ? _ref : this._regexp_capture_any_type_ = /(!>[^<]+<)/g;
    };

    Argument.user_pattern_to_types = function(txt) {
      var captures, me, regex, t, tokens, types, v, val, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      me = Argument.user_pattern_to_types;
      if (!me.map) {
        me.map = {};
        _ref = Argument.types();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          me.map[t.user_pattern()] = t;
        }
      }
      regex = null;
      _ref1 = Argument.types();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        if (t.user_pattern() === txt) {
          val = t;
        }
      }
      if (val) {
        return [regex, [val]];
      }
      captures = XRegExp.split(txt, Argument.regexp_capture_any_type());
      if (captures.length === 1 && captures[0] === txt) {
        return null;
      }
      types = [];
      tokens = [];
      for (_k = 0, _len2 = captures.length; _k < _len2; _k++) {
        v = captures[_k];
        if (me.map[v]) {
          tokens.push("(.+)");
          types.push(me.map[v]);
        } else {
          tokens.push(XRegExp.escape(v));
        }
      }
      regex = XRegExp.globalize(XRegExp(tokens.join("")));
      return [regex, types];
    };

    rw.ize(Argument);

    Argument.read_able("user_pattern", "first_type", "types", "regex");

    Argument.read_write_able_bool("is_start", "is_end");

    function Argument(txt) {
      var regex_and_types;
      this.rw_data().user_pattern = txt;
      regex_and_types = Argument.user_pattern_to_types(txt);
      if (regex_and_types) {
        this.rw_data().regex = regex_and_types[0];
        this.rw_data().types = regex_and_types[1];
        this.rw_data().first_type = this.types()[0];
      }
      this.write("is_start", false);
      this.write("is_end", false);
    }

    Argument.prototype.is_splat = function() {
      if (this.is_plain_text()) {
        return false;
      }
      return (!!this.first_type().is_splat) && this.first_type().is_splat();
    };

    Argument.prototype.extract_args = function(txt, env, line) {
      var all_match, args, i, raw_args, type_matches, v;
      if (this.is_plain_text()) {
        if (txt === this.user_pattern()) {
          return true;
        }
      } else if (this.regex()) {
        raw_args = RegExp.captures(this.regex(), txt);
        if (raw_args && raw_args.length !== 0) {
          args = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = raw_args.length; _i < _len; _i++) {
              v = raw_args[_i];
              _results.push(env.get_if_data(v, line));
            }
            return _results;
          })();
          type_matches = (function() {
            var _i, _len, _results;
            _results = [];
            for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
              v = args[i];
              _results.push(this.types()[i].is_a_match_with(v));
            }
            return _results;
          }).call(this);
          all_match = _.all(type_matches, function(v) {
            return v === true;
          });
          if (txt === "My-List:" && this.user_pattern() === "!>WORD<:") {
            console.log(txt, args, this.types()[0].is_a_match_with(args[0]));
          }
          if (all_match) {
            return args;
          }
        }
      } else {
        if (this.first_type().is_a_match_with(txt)) {
          return [txt];
        }
      }
      return null;
    };

    Argument.prototype.is_plain_text = function() {
      if (this.first_type()) {
        return false;
      } else {
        return true;
      }
    };

    Argument.splat = {
      is_splat: function() {
        return true;
      },
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>...<";
      },
      is_a_match_with: function(arr) {
        return arr.length !== 0;
      },
      convert: function(unk) {
        return unk;
      }
    };

    Argument.ANY = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>ANY<";
      },
      is_a_match_with: function(unk) {
        if (("" + unk).is_whitespace()) {
          return false;
        }
        return true;
      },
      convert: function(unk) {
        return unk;
      }
    };

    Argument["true"] = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>true<";
      },
      is_a_match_with: function(unk) {
        return ("" + unk) === "true";
      },
      convert: function(unk) {
        return true;
      }
    };

    Argument["false"] = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>false<";
      },
      is_a_match_with: function(unk) {
        return ("" + unk) === "false";
      },
      convert: function(unk) {
        return false;
      }
    };

    Argument.true_or_false = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>true_or_false<";
      },
      is_a_match_with: function(unk) {
        return ("" + unk) === "true" || ("" + unk) === "false";
      },
      convert: function(unk) {
        if (unk === "true") {
          return true;
        }
        return false;
      }
    };

    Argument.WORD = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>WORD<";
      },
      is_a_match_with: function(unk) {
        if (!unk.is_whitespace) {
          return false;
        }
        if (unk.is_whitespace()) {
          return false;
        }
        return !unk.is_whitespace();
      },
      convert: function(unk) {
        return unk.strip();
      }
    };

    Argument.NUM = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>NUM<";
      },
      is_a_match_with: function(unk) {
        return !isNaN(parseFloat(unk));
      },
      convert: function(unk) {
        return parseFloat(unk);
      }
    };

    Argument.Noun = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>Noun<";
      },
      is_a_match_with: function(unk) {
        return !!unk.is_a_noun;
      },
      convert: function(unk) {
        return unk;
      }
    };

    Argument.CHAR = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_path) != null ? _ref : _base.user_path = "!>CHAR<";
      },
      is_a_match_with: function(unk) {
        if (!unk.strip) {
          return false;
        }
        return unk.strip().length === 1;
      },
      convert: function(unk) {
        return unk.strip();
      }
    };

    return Argument;

  })();

  module.exports = Argument;

}).call(this);
