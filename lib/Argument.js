// Generated by CoffeeScript 1.3.3
(function() {
  var Argument, rw;

  rw = require("rw_ize");

  Argument = (function() {

    Argument.type_names = ['WORD', 'NUM', 'CHAR'];

    Argument.types = function() {
      var t;
      return this._types_ = (function() {
        var _i, _len, _ref, _results;
        _ref = this.type_names;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          _results.push(this[t]);
        }
        return _results;
      }).call(this);
    };

    Argument.escaped_end_period = /\\\.$/;

    Argument.regexp_types_used = /\!\>([^\s]+)\</g;

    Argument.regexp_any_type = /\!\>[^\s]+\</g;

    Argument.user_pattern_to_type = function(txt) {
      var t, val, _i, _len, _ref;
      _ref = Argument.types();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.user_pattern() === txt) {
          val = t;
        }
      }
      return val;
    };

    rw.ize(Argument);

    Argument.read_able("user_pattern", "type");

    Argument.read_write_able_bool("is_start", "is_end");

    function Argument(txt) {
      this.rw_data().user_pattern = txt;
      this.rw_data().type = Argument.user_pattern_to_type(txt);
      this.write("is_start", false);
      this.write("is_end", false);
    }

    Argument.prototype.is_a_match_with = function(txt) {
      if (this.is_plain_text()) {
        return txt === this.user_pattern();
      } else {
        return this.type().is_a_match_with(txt);
      }
    };

    Argument.prototype.is_plain_text = function() {
      if (this.type()) {
        return false;
      } else {
        return true;
      }
    };

    Argument.WORD = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>WORD<";
      },
      regexp_string: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).reg_str) != null ? _ref : _base.reg_str = "([a-zA-Z0-9\\.\\_\\-]+)";
      },
      is_a_match_with: function(unk) {
        if (unk.is_whitespace()) {
          return false;
        }
        return !unk.is_whitespace();
      },
      convert: function(unk) {
        return unk.strip();
      }
    };

    Argument.NUM = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>NUM<";
      },
      regexp_string: function() {
        var _ref;
        return (_ref = this.regexp_string_data) != null ? _ref : this.regexp_string_data = "([\\-]?[0-9\\.]+)";
      },
      is_a_match_with: function(unk) {
        return !isNaN(parseFloat(unk));
      },
      convert: function(unk) {
        return parseFloat(unk);
      }
    };

    Argument.CHAR = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_path) != null ? _ref : _base.user_path = "!>CHAR<";
      },
      regexp_string: function() {
        var _ref;
        return (_ref = this.regexp_string_data) != null ? _ref : this.regexp_string_data = "([^\\s])";
      },
      is_a_match_with: function(unk) {
        return unk.strip().length === 1;
      },
      convert: function(unk) {
        return unk.strip();
      }
    };

    return Argument;

  })();

  module.exports = Argument;

}).call(this);
