// Generated by CoffeeScript 1.3.3
(function() {
  var Argument, XRegExp, englishy, rw, str_compare, _;

  rw = require("rw_ize");

  _ = require("underscore");

  XRegExp = require('xregexp').XRegExp;

  englishy = require('englishy');

  str_compare = 'englishy'.stringy_compare;

  Argument = (function() {

    Argument.types = function() {
      var t, _ref;
      return (_ref = this._types_) != null ? _ref : this._types_ = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = ['splat', 'WORD', 'NUM', 'CHAR', 'ANY', 'Noun', 'true', 'true_or_false', 'false'];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          t = _ref1[_i];
          _results.push(this[t]);
        }
        return _results;
      }).call(this);
    };

    Argument.escaped_end_period = /\\\.$/;

    Argument.regexp_types_used = /\!\>([^\s]+)\</g;

    Argument.regexp_any_type = /(\!\>[^\s]+\<)/g;

    Argument.regexp_capture_any_type = function() {
      var _ref;
      return (_ref = this._regexp_capture_any_type_) != null ? _ref : this._regexp_capture_any_type_ = /(!>[^<]+<)/g;
    };

    Argument.user_pattern_to_types = function(txt) {
      var captures, me, regex, t, tokens, types, v, val, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      me = Argument.user_pattern_to_types;
      if (!me.map) {
        me.map = {};
        _ref = Argument.types();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          me.map[t.user_pattern()] = t;
        }
      }
      regex = null;
      _ref1 = Argument.types();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        if (t.user_pattern() === txt) {
          val = t;
        }
      }
      if (val) {
        return [regex, [val]];
      }
      captures = XRegExp.split(txt, Argument.regexp_capture_any_type());
      if (captures.length === 1 && captures[0] === txt) {
        return null;
      }
      types = [];
      tokens = [];
      for (_k = 0, _len2 = captures.length; _k < _len2; _k++) {
        v = captures[_k];
        if (me.map[v]) {
          tokens.push("(.+)");
          types.push(me.map[v]);
        } else {
          tokens.push(XRegExp.escape(v));
        }
      }
      regex = XRegExp.globalize(XRegExp(tokens.join("")));
      return [regex, types];
    };

    rw.ize(Argument);

    Argument.read_able("user_pattern", "first_type", "types", "regex");

    Argument.read_write_able_bool("is_start", "is_end");

    function Argument(txt) {
      var regex_and_types;
      this.rw_data().user_pattern = txt;
      regex_and_types = Argument.user_pattern_to_types(txt);
      if (regex_and_types) {
        this.rw_data('regex', regex_and_types[0]);
        this.rw_data('types', regex_and_types[1]);
        this.rw_data('first_type', this.types()[0]);
      }
      this.write("is_start", false);
      this.write("is_end", false);
    }

    Argument.prototype.is_splat = function() {
      if (this.is_plain_text()) {
        return false;
      }
      return (!!this.first_type().is_splat) && this.first_type().is_splat();
    };

    Argument.prototype.extract_args = function(raw_txt, env, line) {
      var args, captures, compiled_arg, ctxt, i, mismatch, origin_args, raw_s, s, target, txt, _i, _len;
      if (!raw_txt.value) {
        raw_txt = new englishy.Stringy(raw_txt);
      }
      txt = raw_txt.value();
      ctxt = env.get_if_data(txt, line);
      target = raw_txt.is_quoted() ? txt : ctxt;
      if (this.regex()) {
        origin_args = [];
        args = [];
        mismatch = false;
        i = -1;
        captures = RegExp.captures(this.regex(), txt);
        if (!captures) {
          return null;
        }
        for (_i = 0, _len = captures.length; _i < _len; _i++) {
          raw_s = captures[_i];
          i += 1;
          s = new ep.Stringy(raw_s);
          origin_args.push(s.value());
          compiled_arg = s.is_quoted() ? s.value() : env.get_if_data(s.value(), line);
          mismatch = !this.types()[i].is_a_match_with(compiled_arg);
          if (mismatch) {
            break;
          }
          args.push(compiled_arg);
        }
        if (mismatch || _.isEmpty(args.length)) {
          return null;
        }
        return [args, origin_args];
      } else if (this.is_plain_text()) {
        if (txt === this.user_pattern() || ctxt === this.user_pattern()) {
          return true;
        }
      } else if (this.types().length === 1) {
        if (this.first_type().is_a_match_with(target)) {
          return [[target], [target]];
        }
      }
      return null;
    };

    Argument.prototype.is_plain_text = function() {
      if (this.first_type()) {
        return false;
      } else {
        return true;
      }
    };

    Argument.splat = {
      is_splat: function() {
        return true;
      },
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>...<";
      },
      is_a_match_with: function(arr) {
        return arr.length !== 0;
      },
      convert: function(unk) {
        return unk;
      }
    };

    Argument.ANY = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>ANY<";
      },
      is_a_match_with: function(unk) {
        if (("" + unk).is_whitespace()) {
          return false;
        }
        return true;
      },
      convert: function(unk) {
        return unk;
      }
    };

    Argument["true"] = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>true<";
      },
      is_a_match_with: function(unk) {
        return ("" + unk) === "true";
      },
      convert: function(unk) {
        return true;
      }
    };

    Argument["false"] = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>false<";
      },
      is_a_match_with: function(unk) {
        return ("" + unk) === "false";
      },
      convert: function(unk) {
        return false;
      }
    };

    Argument.true_or_false = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>true_or_false<";
      },
      is_a_match_with: function(unk) {
        return ("" + unk) === "true" || ("" + unk) === "false";
      },
      convert: function(unk) {
        if (unk === "true") {
          return true;
        }
        return false;
      }
    };

    Argument.WORD = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>WORD<";
      },
      is_a_match_with: function(unk) {
        if (!unk.is_whitespace) {
          return false;
        }
        if (unk.is_whitespace()) {
          return false;
        }
        return !unk.is_whitespace();
      },
      convert: function(unk) {
        return unk.strip();
      }
    };

    Argument.NUM = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>NUM<";
      },
      is_a_match_with: function(unk) {
        return !isNaN(parseFloat(unk));
      },
      convert: function(unk) {
        return parseFloat(unk);
      }
    };

    Argument.Noun = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = "!>Noun<";
      },
      is_a_match_with: function(unk) {
        return !!unk.is_a_noun;
      },
      convert: function(unk) {
        return unk;
      }
    };

    Argument.CHAR = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_path) != null ? _ref : _base.user_path = "!>CHAR<";
      },
      is_a_match_with: function(unk) {
        if (!unk.strip) {
          return false;
        }
        return unk.strip().length === 1;
      },
      convert: function(unk) {
        return unk.strip();
      }
    };

    return Argument;

  })();

  module.exports = Argument;

}).call(this);
