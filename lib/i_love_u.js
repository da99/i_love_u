// Generated by CoffeeScript 1.3.3
(function() {
  var Args, Procedure, as_num, englishy, i_love_u, md_num, parser, rw, word_is_word,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  parser = require('englishy');

  englishy = require('englishy');

  if (!Array.prototype.inject) {
    Array.prototype.inject = function(start, func) {
      var i, memo, _i, _len;
      memo = start;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        i = this[_i];
        memo = func(memo, i);
      }
      return memo;
    };
  }

  if (!RegExp.escape) {
    RegExp.escape = function(s) {
      return s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    };
  }

  if (!RegExp.captures) {
    RegExp.captures = function(r, str) {
      var match, runs, vals;
      r.lastIndex = 0;
      match = null;
      vals = null;
      runs = 0;
      while ((match = r.exec(str))) {
        if (runs > 10 && r.lastIndex === 0) {
          throw new Error("/g flag is not set: " + r);
        }
        if (vals == null) {
          vals = [];
        }
        vals.push(match);
        runs += 1;
      }
      return vals;
    };
  }

  if (!RegExp.first_capture) {
    RegExp.first_capture = function(r, str) {
      var match, vals;
      r.lastIndex = 0;
      match = null;
      vals = null;
      return r.exec(str);
    };
  }

  rw = {};

  rw.ize = function(klass) {
    var m, me, _i, _j, _len, _len1, _ref, _ref1, _results;
    me = arguments.callee;
    if (!me.read_able) {
      me.on_prototype = ["write", "d"];
      me.on_class = ["read_able", "write_able", "read_write_able"];
      me.funcs = {
        read_write_able: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          this.read_able.apply(this, args);
          return this.write_able.apply(this, args);
        },
        d: function() {
          var _ref;
          return (_ref = this.__d) != null ? _ref : this.__d = {};
        },
        read_able: function() {
          var args, prop, _i, _len, _results;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            prop = args[_i];
            this.prototype[prop] = function() {
              return this.d()[arguments.callee.prop_name];
            };
            _results.push(this.prototype[prop].prop_name = prop);
          }
          return _results;
        },
        write_able: function() {
          var args, prop, _base, _i, _len, _ref, _results;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            prop = args[_i];
            if ((_ref = (_base = this.prototype).write_ables) == null) {
              _base.write_ables = [];
            }
            _results.push(this.prototype.write_ables.push(prop));
          }
          return _results;
        },
        write: function(prop, val) {
          if (!(__indexOf.call(this['write_ables'], prop) >= 0)) {
            throw new Error("" + prop + " is not write_able.");
          }
          return this.d()[prop] = val;
        }
      };
    }
    _ref = me.on_prototype;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      klass.prototype[m] = me.funcs[m];
    }
    _ref1 = me.on_class;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      m = _ref1[_j];
      _results.push(klass[m] = me.funcs[m]);
    }
    return _results;
  };

  exports.Args = Args = (function() {

    Args.types = ['WORD', 'NUM', 'CHAR'];

    Args.escaped_end_period = /\\\.$/;

    Args.regexp_types_used = /\!\>([^\s]+)\</g;

    Args.regexp_any_type = /\!\>[^\s]+\</g;

    rw.ize(Args);

    Args.read_write_able("types", "regexp", "any_type_regexp");

    function Args(raw_str) {
      var str, t, v, _i, _j, _len, _len1, _ref, _ref1;
      this.write('types', (function() {
        var _i, _len, _ref, _results;
        _ref = RegExp.captures(Args.regexp_types_used, raw_str);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(v[1]);
        }
        return _results;
      })());
      str = RegExp.escape(raw_str);
      _ref = Args.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        str = str.replace(Args[t].user_pattern(), Args[t].regexp_string());
      }
      if (Args.escaped_end_period.test(str)) {
        str = "^" + str.replace(Args.escaped_end_period, "") + "$";
      }
      this.write('regexp', new RegExp(str, "g"));
      str = RegExp.escape(raw_str);
      _ref1 = Args.types;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        str = str.replace(Args.regexp_any_type, "([^\\s]+)");
      }
      if (Args.escaped_end_period.test(str)) {
        str = "^" + str.replace(Args.escaped_end_period, "") + "$";
      }
      this.write('any_type_regexp', new RegExp(str, "g"));
    }

    Args.prototype.compile = function(env, line, code) {
      var caps, final, i, invalid, raw_v, raw_vals, type, v, vals, _i, _len;
      caps = RegExp.first_capture(this.any_type_regexp(), line);
      if (!caps || caps.length === 0) {
        return null;
      }
      raw_vals = caps.shift();
      vals = [];
      invalid = [];
      for (i = _i = 0, _len = caps.length; _i < _len; i = ++_i) {
        raw_v = caps[i];
        type = Args[this.types()[i]];
        v = env.is_name_of_data(raw_v) ? env.data(raw_v) : raw_v;
        if (type.is_valid(v)) {
          vals.push(v);
        } else {
          invalid.push(v);
        }
      }
      if (invalid.length > 0) {
        console.log("ignored", line, caps, invalid, this.regexp());
      }
      if (invalid.length > 0) {
        return null;
      }
      return final = {
        values: vals,
        types: this.types()
      };
    };

    Args.WORD = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = new RegExp("!>WORD<", "g");
      },
      regexp_string: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).reg_str) != null ? _ref : _base.reg_str = "([a-zA-Z0-9\\.\\_\\-]+)";
      },
      is_valid: function(unk) {
        if (!unk.englishy) {
          return false;
        }
        return !unk.englishy('is_whitespace');
      },
      convert: function(unk) {
        return unk.englishy('strip');
      }
    };

    Args.NUM = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_pat) != null ? _ref : _base.user_pat = new RegExp("!>NUM<", 'g');
      },
      regexp_string: function() {
        var _ref;
        return (_ref = this.regexp_string_data) != null ? _ref : this.regexp_string_data = "([\\-]?[0-9\\.]+)";
      },
      is_valid: function(unk) {
        return parseFloat(unk) !== NaN;
      },
      convert: function(unk) {
        return parseFloat(unk);
      }
    };

    Args.CHAR = {
      d: {},
      user_pattern: function() {
        var _base, _ref;
        return (_ref = (_base = this.d).user_path) != null ? _ref : _base.user_path = new RegExp("!>CHAR<", 'g');
      },
      regexp_string: function() {
        var _ref;
        return (_ref = this.regexp_string_data) != null ? _ref : this.regexp_string_data = "([^\\s])";
      },
      is_valid: function(unk) {
        return unk.englishy('strip').length === 1;
      },
      convert: function(unk) {
        return unk.englishy('strip');
      }
    };

    return Args;

  })();

  exports.i_love_u = i_love_u = (function() {

    i_love_u.No_Match = "no_match";

    i_love_u.Base_Procs = [];

    rw.ize(i_love_u);

    i_love_u.read_write_able('address', 'pattern', 'list', 'procs', 'data');

    i_love_u.read_able('code', 'original_code');

    i_love_u.add_base_proc = function(proc) {
      this.Base_Procs.push(proc);
      return this.Base_Procs = this.Base_Procs.sort(function(a, b) {
        var a_level, b_level, levels;
        levels = {
          low: 10,
          medium: 0,
          high: -10
        };
        a_level = levels[a.priority()];
        b_level = levels[b.priority()];
        return a_level > b_level;
      });
    };

    function i_love_u(str) {
      this.d().original_code = str;
      this.d().code = str.englishy('standardize');
      this.write('procs', [].concat(this.constructor.Base_Procs));
      this.write('list', []);
    }

    i_love_u.prototype.add_to_data = function(k, v) {
      var obj;
      obj = {
        name: k,
        value: v,
        inherits_from: []
      };
      return this.list().push(obj);
    };

    i_love_u.prototype.add_to_list = function(val) {
      return this.list().push(val);
    };

    i_love_u.prototype.is_name_of_data = function(k) {
      var v, val, _i, _len, _ref;
      _ref = this.list();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        if (v.name === k) {
          val = v;
        }
      }
      if (val) {
        return true;
      }
      return false;
    };

    i_love_u.prototype.data = function(k) {
      var v, val, vals, _i, _len, _ref;
      if (k) {
        _ref = this.list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          if (v.name === k) {
            val = v;
          }
        }
        return val.value;
      } else {
        return vals = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.list();
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            v = _ref1[_j];
            if (v.hasOwnProperty("name") && v.hasOwnProperty("value")) {
              _results.push(v);
            }
          }
          return _results;
        }).call(this);
      }
    };

    i_love_u.prototype.run = function() {
      var code_block, compiled, current, i, line, lines, match, me, pair, r_txt, regexp, stop, v, _i, _j, _len, _len1, _ref;
      lines = (new englishy.Englishy(this.code())).to_array();
      me = this;
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        pair = lines[i];
        line = pair[0];
        code_block = pair[1];
        if (line && !code_block) {
          line = line.englishy('remove_end', 'period');
        } else if (line && code_block) {
          line = line.englishy('remove_end', 'colon');
        }
        match = false;
        stop = false;
        current = line;
        compiled = line;
        while (!stop) {
          compiled = current;
          _ref = this.data();
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            v = _ref[_j];
            r_txt = "(?:^|\\s+)" + RegExp.escape(v.name) + "(?:\\s+|$)";
            regexp = new RegExp(r_txt, "g");
            current = current.replace(regexp, " " + v.value + " ").englishy('strip');
          }
          current = this.procs().inject(current, function(memo, o) {
            return o.run(me, memo, code_block);
          });
          stop = compiled === current;
        }
      }
      return this.list();
    };

    return i_love_u;

  })();

  exports.Procedure = Procedure = (function() {

    rw.ize(Procedure);

    Procedure.read_write_able('priority', 'pattern', 'data', 'list', 'procedure');

    Procedure.read_able('args', 'regexp');

    function Procedure(pattern) {
      this.d().data = {};
      this.d().pattern = pattern;
      this.d().list = [];
      this.d().priority = 'low';
      this.d().args = new Args(pattern.englishy('strip'));
      this.d().regexp = this.args().regexp();
    }

    Procedure.prototype.run = function(env, line, code) {
      var captures, l, r, results;
      results = this.args().compile(env, line, code);
      if (!results) {
        return line;
      }
      captures = RegExp.first_capture(this.regexp(), line);
      results.values.unshift(captures[0]);
      this.d().data["Args"] = results.values;
      this.d().data["Block"] = code;
      this.d().data["Outer-Block"] = env;
      r = this.procedure()(this);
      if (r && r.ignore_this) {
        return results.line;
      }
      l = line.replace(captures[0], r.toString());
      return l;
    };

    return Procedure;

  })();

  md_num = new Procedure("!>NUM< !>CHAR< !>NUM<");

  md_num.write('priority', 'high');

  md_num.write('procedure', function(env) {
    var m, n, op;
    m = env.data()['Args'][1];
    op = env.data()['Args'][2];
    n = env.data()['Args'][3];
    switch (op) {
      case '*':
        return parseFloat(m) * parseFloat(n);
      case '/':
        return parseFloat(m) / parseFloat(n);
      default:
        return {
          ignore_this: true
        };
    }
  });

  as_num = new Procedure("!>NUM< !>CHAR< !>NUM<");

  as_num.write('procedure', function(env) {
    var m, n, op;
    m = env.data()['Args'][1];
    op = env.data()['Args'][2];
    n = env.data()['Args'][3];
    switch (op) {
      case '+':
        return parseFloat(m) + parseFloat(n);
      case '-':
        return parseFloat(m) - parseFloat(n);
      default:
        return {
          ignore_this: true
        };
    }
  });

  word_is_word = new Procedure("!>WORD< is: !>WORD<.");

  word_is_word.write('procedure', function(env) {
    var name, pair, val;
    pair = env.data()['Args'];
    name = pair[1];
    val = pair[2];
    env.data()['Outer-Block'].add_to_data(name, val);
    return val;
  });

  i_love_u.add_base_proc(as_num);

  i_love_u.add_base_proc(md_num);

  i_love_u.add_base_proc(word_is_word);

}).call(this);
