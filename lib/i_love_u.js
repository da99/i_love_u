// Generated by CoffeeScript 1.3.3
(function() {
  var Procedure, add_num, englishy, i_love_u, parser, rw, word_is_word,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  parser = require('englishy');

  englishy = require('englishy');

  Array.prototype.rubyish = {
    inject: function(stat, func) {
      var i, memo, _i, _len;
      memo = start;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        i = this[_i];
        memo = func(memo, i);
      }
      return memo;
    }
  };

  if (!RegExp.escape) {
    RegExp.escape = function(s) {
      return s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    };
  }

  rw = {};

  rw.ize = function(klass) {
    var m, me, _i, _j, _len, _len1, _ref, _ref1, _results;
    me = arguments.callee;
    if (!me.read_able) {
      me.on_prototype = "write".split(/\s+/);
      me.on_class = "read_able write_able read_write_able".split(/\s+/);
      me.funcs = {
        read_write_able: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          this.read_able.apply(this, args);
          return this.write_able.apply(this, args);
        },
        read_able: function() {
          var args, prop, _i, _len, _results;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            prop = args[_i];
            this.prototype[prop] = function() {
              return this.d[arguments.callee.prop_name];
            };
            _results.push(this.prototype[prop].prop_name = prop);
          }
          return _results;
        },
        write_able: function() {
          var args, prop, _base, _i, _len, _ref, _results;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            prop = args[_i];
            if ((_ref = (_base = this.prototype).write_ables) == null) {
              _base.write_ables = [];
            }
            _results.push(this.prototype.write_ables.push(prop));
          }
          return _results;
        },
        write: function(prop, val) {
          if (!(__indexOf.call(this['write_ables'], prop) >= 0)) {
            throw new Error("" + prop + " is not write_able.");
          }
          return this.d[prop] = val;
        }
      };
    }
    _ref = me.on_prototype;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      klass.prototype[m] = me.funcs[m];
    }
    _ref1 = me.on_class;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      m = _ref1[_j];
      _results.push(klass[m] = me.funcs[m]);
    }
    return _results;
  };

  exports.i_love_u = i_love_u = (function() {

    i_love_u.No_Match = "no_match";

    i_love_u.Base_Procs = [];

    rw.ize(i_love_u);

    i_love_u.read_write_able('address', 'pattern', 'stack', 'procs', 'data');

    i_love_u.read_able('code', 'original_code');

    function i_love_u(str) {
      this.d = {};
      this.d.original_code = str;
      this.d.original_code = str;
      this.d.code = str.englishy('standardize');
      this.d.procs = [].concat(this.Base_Procs);
      this.d.stack = [];
      this.d.data = {};
    }

    i_love_u.prototype.run = function() {
      var code, compiled, current, i, line, lines, match, me, pair, stop, _i, _len;
      lines = (new englishy.Englishy(this.code())).to_array();
      me = this;
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        pair = lines[i];
        line = pair[0];
        code = pair[1];
        match = false;
        stop = false;
        current = line;
        compiled = line;
        while (!stop) {
          stop = compiled === current;
        }
      }
      return stack;
    };

    return i_love_u;

  })();

  exports.Procedure = Procedure = (function() {

    rw.ize(Procedure);

    Procedure.read_write_able('pattern', 'regexp', 'data', 'stack', 'procedure');

    Procedure.prototype.word_reg = /\[\s*WORD\s*\]/g;

    Procedure.prototype.num_reg = /\[\s*NUM\s*\]/g;

    function Procedure(pattern) {
      var str;
      this.d = {};
      this.d.data = {};
      this.d.pattern = pattern;
      this.d.stack = [];
      str = RegExp.escape(pattern.englishy('strip'));
      str = str.replace(this.word_reg, "([a-zA-Z0-9\.\_\-]+)");
      str = str.replace(this.num_reg, "([\+\-]?[\-0-9\.]+)");
      this.d.regexp = new RegExp(str, "g");
    }

    Procedure.prototype.run = function(env, line, code) {
      var r;
      if (!this.regexp().test(line)) {
        return line;
      }
      this.d.data["Args"] = captures;
      this.d.data["Block"] = code;
      this.d.data["Outer-Block"] = env;
      r = procedure(this);
      this.stack().push(r);
      return line.replace(this.regexp, r.toString());
    };

    return Procedure;

  })();

  add_num = new Procedure("[NUM] + [NUM]");

  add_num.write('procedure', function(env) {
    return env.data()['Args'].inject(0, function(m, n) {
      return m.to_f + n.to_f;
    });
  });

  word_is_word = new Procedure("[WORD] is [WORD]");

  word_is_word.write('procedure', function(env) {
    var name, val;
    name = env.data()['Args'][0];
    val = env.data()['Args'][1];
    return env.data()['Outer-Block'].data()[name] = val;
  });

  i_love_u.Base_Procs.push(add_num);

  i_love_u.Base_Procs.push(word_is_word);

}).call(this);
