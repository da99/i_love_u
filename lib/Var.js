// Generated by CoffeeScript 1.3.3
(function() {
  var Var, rw, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  rw = require("rw_ize");

  _ = require("underscore");

  Var = (function() {

    rw.ize(Var);

    Var.read_able("name", "value");

    Var.read_write_able("is_local_only", "regexp");

    function Var(name, val, yield_to) {
      this.is_named = __bind(this.is_named, this);
      this.rw("name", name);
      this.rw("value", val);
      this.rw("is_local_only", false);
      if (yield_to) {
        yield_to(this);
      }
    }

    Var.prototype.has_regexp_name = function() {
      return _.isRegExp(this.regexp());
    };

    Var.prototype.is_a_var = function() {
      return true;
    };

    Var.prototype.is_user_defined = function() {
      var _base;
      return (!(typeof (_base = this.value()).is_a_procedure === "function" ? _base.is_a_procedure() : void 0)) && (!(typeof this.has_regexp_name === "function" ? this.has_regexp_name() : void 0)) && this.name() !== 'List';
    };

    Var.prototype.is_named = function(n) {
      if (this.name() === n) {
        return true;
      }
      if (!this.has_regexp_name()) {
        return false;
      }
      return this.regexp().test(n);
    };

    return Var;

  })();

  module.exports = Var;

  module.exports.to_var = function(args) {
    var _base;
    switch (args.length) {
      case 2:
        return new Var(args[0], args[1]);
      case 1:
        if (typeof (_base = args[0]).is_a_var === "function" ? _base.is_a_var() : void 0) {
          return v;
        } else {
          throw new Error("Unknown argument: " + args[0]);
        }
        break;
      default:
        throw new Error("Unknown arguments: " + (Array.prototype.slice.apply(args)));
    }
  };

  module.exports.new_local = function() {
    var args, v;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    v = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args), t = typeof result;
      return t == "object" || t == "function" ? result || child : child;
    })(Var, args, function(){});
    v.is_local_only(true);
    return v;
  };

}).call(this);
