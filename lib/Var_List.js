// Generated by CoffeeScript 1.3.3
(function() {
  var Arguments_Match, Line, Var, Var_List, rw, _,
    __slice = [].slice;

  rw = require("rw_ize");

  _ = require("underscore");

  Var = require("i_love_u/lib/Var");

  Line = require("i_love_u/lib/Line");

  Arguments_Match = require("i_love_u/lib/Arguments_Match");

  Var_List = (function() {

    Var_List.counter = 0;

    rw.ize(Var_List);

    Var_List.read_able("env", "object_id", "vars", "procs", "pattern_based");

    function Var_List(env) {
      this.rw('env', env);
      this.rw('object_id', ++Var_List.counter);
      this.rw('vars', {});
      this.rw('procs', []);
      this.rw('pattern_based', {});
    }

    Var_List.prototype.is_a_var_list = function() {
      return true;
    };

    Var_List.prototype.array = function(type) {
      var arr, k, v, vars;
      if (arguments.length === 0) {
        type = 'all';
      }
      vars = (function() {
        var _ref, _ref1, _results;
        switch (type) {
          case 'vars':
          case 'var_values':
            arr = [];
            _ref = this.vars();
            for (k in _ref) {
              v = _ref[k];
              if (v.is_user_defined()) {
                if (type === 'var_values') {
                  arr.push(v.value());
                } else {
                  arr.push(v);
                }
              }
            }
            return arr;
          case 'procedures':
            _ref1 = this.vars();
            _results = [];
            for (k in _ref1) {
              v = _ref1[k];
              if (typeof v.is_a_procedure === "function" ? v.is_a_procedure() : void 0) {
                _results.push(v);
              }
            }
            return _results;
          case 'all':
            return this.vars();
          default:
            throw new Error("Unknown var type: " + type);
        }
      }).call(this);
      if (!this.env().is_read_local()) {
        vars = this.env().read().vars().array(type).concat(vars);
      }
      return vars;
    };

    Var_List.prototype.has_named = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return !!this.get.apply(this, args);
    };

    Var_List.prototype.get_or_throw = function(name) {
      return this.get(name) || (function() {
        throw new Error("Variable not found: " + name);
      })();
    };

    Var_List.prototype.get_if_data = function(name, line) {
      if (!(typeof line.is_a_line === "function" ? line.is_a_line() : void 0)) {
        throw new Error("Line is required.");
      }
      return this.get(name, line) || name;
    };

    Var_List.prototype.get_vars_with = function(name, line) {
      var found, _vars;
      _vars = null;
      if (!this.env().envs().is_read_local()) {
        _vars = this.env().envs().read().vars().get_vars_with(name, line);
      }
      if (!_vars) {
        _vars = this.vars()[name] ? this.vars() : (found = _.find(this.pattern_based(), function(v) {
          return v.is_named(name);
        }), found && this.vars());
      }
      return _vars;
    };

    Var_List.prototype.get = function(name, line) {
      var v, vars;
      vars = this.get_vars_with(name, line);
      if (!vars) {
        return vars;
      }
      if (!vars[name]) {
        return vars[name];
      }
      v = vars[name];
      if (v && v.is_local_only() && line.calling_env() !== this.env()) {
        return null;
      }
      return v;
    };

    Var_List.prototype.push_name_and_value = function(name, val) {
      if (arguments.length !== 2) {
        throw new Error("Arguments length can only be 2: " + arguments);
      }
      return this.push(new Var(name, val));
    };

    Var_List.prototype.push = function(v) {
      var proc, _base;
      if (arguments.length !== 1) {
        throw new Error(".push only accepts one argument.");
      }
      if (!this.env().is_write_local()) {
        return this.env().envs().write().vars().push(v);
      }
      if (this.has_named(v.name())) {
        throw new Error("Name for var already defined: " + (v.name()));
      }
      this.vars()[v.name()] = v;
      if (typeof (_base = v.value()).is_a_procedure === "function" ? _base.is_a_procedure() : void 0) {
        proc = v.value();
        switch (proc.position()) {
          case 'top':
            this.procs().unshift(proc);
            break;
          case 'middle':
            this.procs().splice(Math.ceil(this.procs().length / 2), 0, proc);
            break;
          case 'bottom':
            this.procs().push(proc);
            break;
          default:
            throw new Error("Unknown position for \"" + (proc.pattern()) + "\": " + (proc.position()));
        }
      }
      return v;
    };

    Var_List.prototype.update_name_and_value = function(name, val) {
      var vars;
      vars = this.get_vars_with(name);
      if (!vars) {
        this.get_or_throw(name);
      }
      vars[name] = new Var(name, val);
      return vars[name];
    };

    Var_List.prototype.remove = function(n) {
      var i, p, proc, val, _i, _len, _ref;
      if (!this.to_local()) {
        return this.scope.remove(n);
      }
      if (!this.is_named(n)) {
        throw new Error("Not found: " + n);
      }
      val = this.vars()[n];
      delete this.vars()[n];
      proc = val && val.value();
      if (typeof proc.is_a_procedure === "function" ? proc.is_a_procedure() : void 0) {
        _ref = this.procs();
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          p = _ref[i];
          if (p === proc) {
            break;
          }
        }
        if (i > -1) {
          this.procs().splice(i, 1);
        }
      }
      return val;
    };

    Var_List.prototype.run_line_tokens = function(pair) {
      var is_any_match, is_full_match, line, match, me, partial_match, proc, _i, _len, _ref;
      match = new Arguments_Match(new Line(pair, this.env()));
      if (!this.env().is_read_local()) {
        match = this.env().envs().read().run_line_tokens(pair);
      }
      if (typeof match.is_full_match === "function" ? match.is_full_match() : void 0) {
        return match;
      }
      me = this;
      if (match) {
        line = match.line();
        is_full_match = match.is_full_match();
        partial_match = match.is_a_match();
      } else {
        line = new Line(pair, env);
        is_full_match = false;
        partial_match = false;
      }
      while (true) {
        is_any_match = false;
        _ref = this.procs();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          proc = _ref[_i];
          while (true) {
            match = new Arguments_Match(line, proc);
            if (!match.is_a_match()) {
              break;
            }
            partial_match = is_any_match = true;
            if (match.is_full_match()) {
              is_full_match = true;
              break;
            }
          }
          if (is_full_match) {
            break;
          }
        }
        if (is_full_match) {
          break;
        }
        if (!is_any_match) {
          break;
        }
      }
      return match;
    };

    return Var_List;

  })();

  module.exports = Var_List;

}).call(this);
